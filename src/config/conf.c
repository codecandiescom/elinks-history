/* Config file and commandline proccessing */
/* $Id: conf.c,v 1.8 2002/05/08 13:55:01 pasky Exp $ */

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <stdio.h>
#include <string.h>
#include <sys/types.h>
#include <sys/stat.h> /* OS/2 needs this after sys/types.h */
#ifdef HAVE_FCNTL_H
#include <fcntl.h> /* OS/2 needs this after sys/types.h */
#endif
#ifdef HAVE_UNISTD_H
#include <unistd.h>
#endif

#include "links.h"

#include "bfu/align.h"
#include "bfu/bfu.h"
#include "config/conf.h"
#include "config/kbdbind.h"
#include "config/options.h"
#include "intl/language.h"
#include "lowlevel/home.h"
#include "lowlevel/terminal.h"
#include "util/secsave.h"


unsigned char *_parse_options(int argc, unsigned char *argv[], struct option **opt)
{
	unsigned char *location = NULL;

	while (argc) {
		argv++, argc--;

		if (argv[-1][0] == '-') {
			struct option *option;
			struct option **oplist;

			/* TODO: get_opt_rec() - but we must get rid of oplist
			 * first. */

			for (oplist = opt; (option = *oplist); oplist++) {
				for (; option->name; option++) {
					unsigned char *cname = cmd_name(option->name);

					if (option->rd_cmd &&
					    option->flags & OPT_CMDLINE &&
					    ((cname &&
					      !strcasecmp(cname,
							 &argv[-1][(argv[-1][1] == '-' ? 2 : 1)])) ||
					     !strcasecmp(option->name,
						         &argv[-1][(argv[-1][1] == '-' ? 2 : 1)]))) {
						unsigned char *err = option->rd_cmd(option, &argv, &argc);

						mem_free(cname);

						if (err) {
							if (err[0])
								fprintf(stderr, "Error parsing option %s: %s\n", argv[-1], err);

							return NULL;
						}

						goto found;
					}

					mem_free(cname);
				}
			}

			goto unknown_option;

		} else if (!location) {
			location = argv[-1];

		} else {
unknown_option:		fprintf(stderr, "Unknown option %s\n", argv[-1]);

			return NULL;
		}

found:
	}

	return location ? location : (unsigned char *) "";
}

unsigned char *parse_options(int argc, unsigned char *argv[])
{
	return _parse_options(argc, argv, all_options);
}

unsigned char *get_token(unsigned char **line)
{
	unsigned char *s = NULL;
	int l = 0;
	int escape = 0;
	int quote = 0;

	while (**line == ' ' || **line == 9) (*line)++;
	if (**line) {
		for (s = init_str(); **line; (*line)++) {
			if (escape)
				escape = 0;
			else if (**line == '\\') {
				escape = 1;
				continue;
			}
			else if (**line == '"') {
				quote = !quote;
			    	continue;
			}
			else if ((**line == ' ' || **line == 9) && !quote)
				break;
			add_chr_to_str(&s, &l, **line);
		}
	}
	return s;
}

void parse_config_file(unsigned char *name, unsigned char *file, struct option **opt)
{
	int error = 0;
	int line = 0;

	while (file[0]) {
		struct option **optlist;
		struct option *option;
		unsigned char *id, *val, *tok = NULL;
		int id_len, val_len, tok_len;

		/* New line */
		line++;
		while (file[0] && (file[0] == ' ' || file[0] == 9)) file++;

		/* Get identifier */
		id = file;
		while (file[0] && file[0] > ' ') file++;
		id_len = file - id;

		/* No identifier? */
		if (! id_len) {
			if (file[0]) file++;
			continue;
		}

		/* Skip separator */
		while (file[0] == 9 || file[0] == ' ') file++;

		/* Get value */
		val = file;
		while (file[0] && file[0] != 10 && file[0] != 13) file++;
		val_len = file - val;

		/* Possibly move to new line */
		if (file[0]) {
			if ((file[1] == 10 || file[1] == 13) && file[0] != file[1]) file++;
			file++;
		}

		/* Comment? */
		if (id[0] == '#') continue;

		/* Get token or go on */
		tok = get_token(&id);
		if (!tok) continue;

		tok_len = strlen(tok);

		/* TODO: get_opt_rec() - but we must get rid of oplist
		 * first. */

		for (optlist = opt; (option = *optlist); optlist++) {
		    	for (; option->name; option++) {
				if (option->flags & OPT_CFGFILE &&
				    tok_len == strlen(option->name) &&
				    !casecmp(tok, option->name, tok_len)) {
					unsigned char *value = memacpy(val, val_len);
					unsigned char *err = option->rd_cfg(option, value);

					if (err) {
						if (err[0])
							fprintf(stderr, "Error parsing config file %s, line %d: %s\n",
								name, line, err);
						error = 1;
					}

					mem_free(value);
					goto next;
				}
			}
		}

		fprintf(stderr, "Unknown option in config file %s, line %d\n", name, line);
		error = 1;
next:
		if (tok) mem_free(tok);
	}

	if (error) {
		fprintf(stderr, "\007");
		sleep(3);
	}
}

unsigned char *create_config_string(struct option *option)
{
	unsigned char *str = init_str();
	int len = 0;

	add_to_str(&str, &len,
		   "# This file is automatically generated by Links "
		   "-- please DO NOT edit!!" NEWLINE
		   "# For own options (like keybindings), use user.cfg.");

	for (; option->name; option++) {
		if (option->wr_cfg) {
			option->wr_cfg(option, &str, &len);
		}
	}

	add_to_str(&str, &len, NEWLINE);

	return str;
}

#define FILE_BUF	1024

unsigned char cfg_buffer[FILE_BUF];

unsigned char *read_config_file(unsigned char *name)
{
	int h, r;
	int l = 0;
	unsigned char *s;
	if ((h = open(name, O_RDONLY | O_NOCTTY)) == -1) return NULL;
	set_bin(h);
	s = init_str();
	while ((r = read(h, cfg_buffer, FILE_BUF)) > 0) {
		int i;
		for (i = 0; i < r; i++) if (!cfg_buffer[i]) cfg_buffer[i] = ' ';
		add_bytes_to_str(&s, &l, cfg_buffer, r);
	}
	if (r == -1) mem_free(s), s = NULL;
	close(h);
	return s;
}

#undef FILE_BUF


void
load_config_file(unsigned char *prefix, unsigned char *name)
{
	unsigned char *c, *config_file;

	config_file = straconcat(prefix, name, NULL);
	if (!config_file) return;

	c = read_config_file(config_file);
	if (c) goto ok;
	mem_free(config_file);

	config_file = straconcat(prefix, ".", name, NULL);
	if (!config_file) return;

	c = read_config_file(config_file);
	if (c) goto ok;

	mem_free(config_file);
	return;

ok:
	parse_config_file(config_file, c, all_options);
	mem_free(c);
	mem_free(config_file);
}

void load_config()
{
	load_config_file("/etc/", "links.cfg");
	load_config_file(links_home, "links.cfg");
	load_config_file(links_home, "html.cfg");
	load_config_file(links_home, "user.cfg");
}

int
write_config_file(unsigned char *prefix, unsigned char *name, struct option *o,
		  struct terminal *term)
{
	int ret = -1;
	struct secure_save_info *ssi;
	unsigned char *config_file;
	unsigned char *cfg_str = create_config_string(o);

	if (!cfg_str) return -1;
	
	config_file = straconcat(prefix, name, NULL);
	if (!config_file) goto free_cfg_str;
	
	ssi = secure_open(config_file, 0177);
	if (!ssi) goto free_config_file;

	secure_fputs(ssi, cfg_str);
	ret = secure_close(ssi);

	if (ret && term) {
		msg_box(term, NULL,
			TEXT(T_CONFIG_ERROR), AL_CENTER | AL_EXTD_TEXT,
			TEXT(T_UNABLE_TO_WRITE_TO_CONFIG_FILE), "\n",
			config_file, ": ", strerror(ret), NULL,
			NULL, 1,
			TEXT(T_CANCEL), NULL, B_ENTER | B_ESC);
	}

free_config_file:
	mem_free(config_file);
	
free_cfg_str:
	mem_free(cfg_str);

	return ret;
}

void write_config(struct terminal *term)
{
	write_config_file(links_home, "links.cfg", links_options, term);
}

void write_html_config(struct terminal *term)
{
	write_config_file(links_home, "html.cfg", html_options, term);
}
