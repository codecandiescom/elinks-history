/* Info dialogs */
/* $Id: info.c,v 1.41 2003/05/15 23:37:11 zas Exp $ */

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#ifdef HAVE_UNISTD_H
#include <unistd.h>
#endif

#include "elinks.h"

#include "bfu/msgbox.h"
#include "dialogs/info.h"
#include "dialogs/refresh.h"
#include "config/options.h"
#include "document/cache.h"
#include "document/html/renderer.h"
#include "intl/gettext/libintl.h"
#include "lowlevel/select.h"
#include "terminal/terminal.h"
#include "sched/sched.h"
#include "sched/session.h"
#include "util/conv.h"
#ifdef LEAK_DEBUG
#include "util/memdebug.h"
#endif
#include "util/memlist.h"
#include "util/memory.h"
#include "util/string.h"


void
menu_about(struct terminal *term, void *d, struct session *ses)
{
	unsigned char *s;

	/* XXX: The s is then gettextized again inside of msgbox, it looks. */

	s = straconcat(
		_("ELinks ", term),
		/* FIXME: This should be elsewhere. */
		VERSION_STRING "\n",
#ifdef DEBUG
		"("
#ifdef __DATE__
		__DATE__
#endif
		" "
#ifdef __TIME__
		__TIME__
#endif
		")"
#endif
		"\n",
		"\n",
		_("Text WWW browser", term),

		"\n\n",
		_("Features:", term),
#ifndef DEBUG
		_(" Standard", term), ",",
#else
		_(" Debug", term), ",",
#endif
#ifdef FASTMEM
		_(" Fastmem", term), ",",
#endif
#ifdef HAVE_SSL
		_(" SSL", term),
#ifdef HAVE_OPENSSL
		"(OpenSSL)",
#elif defined(HAVE_GNUTLS)
		"(GNUTLS)",
#endif
		 ",",
#endif
#ifdef HAVE_LUA
		_(" Lua", term), ",",
#endif
#ifdef IPV6
		_(" IPv6", term), ",",
#endif
#ifdef BOOKMARKS
		_(" Bookmarks", term), ",",
#endif
#ifdef COOKIES
		_(" Cookies", term), ",",
#endif
#ifdef GLOBHIST
		_(" GlobHist", term), ",",
#endif
#ifdef HAVE_ZLIB_H
		_(" gzip", term), ",",
#endif
#ifdef HAVE_BZLIB_H
		_(" bzip2", term),
#endif
		NULL
	);

	if (s) {
		msg_box(term, getml(s, NULL),
			N_("About"), AL_CENTER,
			s,
			NULL, 1,
			N_("OK"), NULL, B_ENTER | B_ESC);
	}
}

/* TODO: This should be autogenerated. */
void
menu_keys(struct terminal *term, void *d, struct session *ses)
{
	msg_box(term, NULL,
		N_("Keys"), AL_LEFT,
		N_("ESC      display menu\n"
		   "^C, q    quit\n"
		   "^P, ^N   scroll up, down\n"
		   "[, ]     scroll left, right\n"
		   "up, down select link\n"
		   "->       follow link\n"
		   "<-       go back\n"
		   "g        go to url\n"
		   "G        go to url based on current url\n"
		   "/        search\n"
		   "?        search back\n"
		   "n        find next\n"
		   "N        find previous\n"
		   "=        document info\n"
		   "|        header info\n"
		   "\\        document source\n"
		   "d        download"),
		NULL, 1,
		N_("OK"), NULL, B_ENTER | B_ESC);
}

void
menu_copying(struct terminal *term, void *d, struct session *ses)
{
	msg_box(term, NULL,
		N_("Copying"), AL_CENTER | AL_EXTD_TEXT,
		N_("ELinks "), VERSION_STRING,
		N_("\n"
		   "\n"
		   "(C) 1999 - 2002 Mikulas Patocka\n"
		   "(C) 2001 - 2003 Petr Baudis\n"
		   "\n"
		   "This program is free software; you can redistribute it "
		   "and/or modify it under the terms of the GNU General Public "
		   "License as published by the Free Software Foundation; "
		   "either version 2 of the License, or (at your option) any "
		   "later version."), NULL,
		NULL, 1,
		N_("OK"), NULL, B_ENTER | B_ESC);
}


void
res_inf(struct terminal *term, void *d, struct session *ses)
{
	unsigned char *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8, *a9, *a10,
		      *a11, *a12, *a13, *a14, *a15, *a16;
	int l = 0;
	struct refresh *r;

	r = mem_alloc(sizeof(struct refresh));
	if (!r)	return;

	/* FIXME: allocation failures are not handled here. */
#define create_str(x, s1, num)	l = 0; (x) = init_str(); \
				add_to_str(&(x), &l, (s1)); \
				add_num_to_str(&(x), &l, (num)); \
				add_chr_to_str(&(x), &l, ' ');

	create_str(a1, ": ", select_info(CI_FILES));
	create_str(a2, ", ", select_info(CI_TIMERS));
	l = 0; a3 = init_str(); add_to_str(&a3, &l, ".\n");

	create_str(a4, ": ", connect_info(CI_FILES));
	create_str(a5, ", ", connect_info(CI_CONNECTING));
	create_str(a6, ", ", connect_info(CI_TRANSFER));
	create_str(a7, ", ", connect_info(CI_KEEP));
	l = 0; a8 = init_str(); add_to_str(&a8, &l, ".\n");

	create_str(a9, ": ", cache_info(CI_BYTES));
	create_str(a10, ", ", cache_info(CI_FILES));
	create_str(a11, ", ", cache_info(CI_LOCKED));
	create_str(a12, ", ", cache_info(CI_LOADING));
	l = 0; a13 = init_str(); add_to_str(&a13, &l, ".\n");

	create_str(a14, ": ", formatted_info(CI_FILES));
	create_str(a15, ", ", formatted_info(CI_LOCKED));
	l = 0; a16 = init_str(); add_to_str(&a16, &l, ".");

#undef create_str

	msg_box(term, getml(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, NULL),
		N_("Resources"), AL_LEFT | AL_EXTD_TEXT,
		N_("Resources"), a1,
		N_("handles"), a2,
		N_("timers"), a3,
		N_("Connections"), a4,
		N_("connections"), a5,
		N_("connecting"), a6,
		N_("transferring"), a7,
		N_("keepalive"), a8,
		N_("Memory cache"), a9,
		N_("bytes"), a10,
		N_("files"), a11,
		N_("locked"), a12,
		N_("loading"), a13,
		N_("Formatted document cache"), a14,
		N_("documents"), a15,
		N_("locked"), a16, NULL,
		r, 1,
		N_("OK"), NULL, B_ENTER | B_ESC);

	refresh_init(r, term, ses, d, res_inf);
}

void
cache_inf(struct terminal *term, void *d, struct session *ses)
{
	unsigned char *a;
	int l = 0;
	struct refresh *r;
	struct cache_entry *ce, *cache;
	unsigned int count = 0;
	int truncated = 0;

	r = mem_alloc(sizeof(struct refresh));
	if (!r)	return;

	a = init_str();
	if (!a) {
		mem_free(r);
		return;
	}

	cache = (struct cache_entry *) cache_info(CI_LIST);
	foreach (ce, *cache) {
		if (count++ < term->y - 10) { /* 10 seems a kool value. --Zas */
			add_chr_to_str(&a, &l, '\n');
#ifdef DEBUG
			if (ce->incomplete)
				add_chr_to_str(&a, &l, '*');
			else /* number of references */
				add_num_to_str(&a, &l, ce->refcount);
			add_chr_to_str(&a, &l, ' ');
#endif
			/* FIXME: What to do with long urls ? they wrap for now
			 * but if one is very long then no other is displayed. */
			add_to_str(&a, &l, ce->url);

#ifdef DEBUG
			/* size */
			add_chr_to_str(&a, &l, ' ');
			add_knum_to_str(&a, &l, ce->data_size);
#endif
		} else if (!truncated) truncated = count;
	}

	if (!count) {
		add_chr_to_str(&a, &l, '\n');
		add_to_str(&a, &l, _("No entry.", term));
	} else if (truncated) {
		unsigned char buf[256];

		add_chr_to_str(&a, &l, '\n');

		snprintf(buf, 64, _("%ld more entries.", term),
			count - truncated + 1);
		add_to_str(&a, &l, buf);
	}

	msg_box(term, getml(a, NULL),
		N_("Cache info"), AL_LEFT | AL_EXTD_TEXT,
		N_("Cache content"), ":", a, NULL,
		r, 1,
		N_("OK"), NULL, B_ENTER | B_ESC);

	refresh_init(r, term, ses, d, cache_inf);
}

#ifdef LEAK_DEBUG

void
memory_inf(struct terminal *term, void *d, struct session *ses)
{
	struct refresh *r;
	char *fmttext;
	unsigned int message_size;
	char *message;

	fmttext = _("%ld bytes of memory allocated.", term);
	if (!*fmttext) return;

	r = mem_alloc(sizeof(struct refresh));
	if (!r) return;

	message_size = strlen(fmttext) + 40; /* sufficient ;) */
	message = mem_alloc(message_size);
	if (!message) {
		mem_free(r);
		return;
	}

	snprintf(message, message_size, fmttext, mem_amount);

	msg_box(term, getml(message, NULL),
		N_("Memory info"), AL_CENTER,
		message,
		r, 1,
		N_("OK"), NULL, B_ENTER | B_ESC);

	refresh_init(r, term, ses, d, memory_inf);
}

#endif
