/* Config file and commandline proccessing */
/* $Id: conf.c,v 1.1 2002/04/27 13:15:51 pasky Exp $ */

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#ifdef HAVE_FCNTL_H
#include <fcntl.h>
#endif
#include <stdio.h>
#include <string.h>
#include <sys/stat.h>
#include <sys/types.h>
#ifdef HAVE_UNISTD_H
#include <unistd.h>
#endif

#include <links.h>

#include <main.h>
#include <bfu/align.h>
#include <bfu/bfu.h>
#include <config/conf.h>
#include <config/kbdbind.h>
#include <config/options.h>
#include <intl/language.h>
#include <lowlevel/terminal.h>
#include <util/secsave.h>


unsigned char *_parse_options(int argc, unsigned char *argv[], struct option **opt)
{
	unsigned char *location = NULL;

	while (argc) {
		argv++, argc--;

		if (argv[-1][0] == '-') {
			struct option *option;
			struct option **oplist;

			for (oplist = opt; (option = *oplist); oplist++) {
				int i;

				for (i = 0; option[i].cfg_name || option[i].cmd_name; i++) {
					if (option[i].rd_cmd &&
					    option[i].cmd_name &&
					    !strcasecmp(option[i].cmd_name, &argv[-1][(argv[-1][1] == '-' ? 2 : 1)])) {
						unsigned char *err = option[i].rd_cmd(&option[i], &argv, &argc);

						if (err) {
							if (err[0])
								fprintf(stderr, "Error parsing option %s: %s\n", argv[-1], err);

							return NULL;
						}

						goto found;
					}
				}
			}

			goto unknown_option;

		} else if (!location) {
			location = argv[-1];

		} else {
unknown_option:		fprintf(stderr, "Unknown option %s\n", argv[-1]);

			return NULL;
		}

found:
	}

	return location ? location : (unsigned char *) "";
}

unsigned char *parse_options(int argc, unsigned char *argv[])
{
	return _parse_options(argc, argv, all_options);
}

unsigned char *get_token(unsigned char **line)
{
	unsigned char *s = NULL;
	int l = 0;
	int escape = 0;
	int quote = 0;

	while (**line == ' ' || **line == 9) (*line)++;
	if (**line) {
		for (s = init_str(); **line; (*line)++) {
			if (escape)
				escape = 0;
			else if (**line == '\\') {
				escape = 1;
				continue;
			}
			else if (**line == '"') {
				quote = !quote;
			    	continue;
			}
			else if ((**line == ' ' || **line == 9) && !quote)
				break;
			add_chr_to_str(&s, &l, **line);
		}
	}
	return s;
}

void parse_config_file(unsigned char *name, unsigned char *file, struct option **opt)
{
	int error = 0;
	int line = 0;

	while (file[0]) {
		struct option **optlist;
		struct option *option;
		unsigned char *id, *val, *tok = NULL;
		int id_len, val_len, tok_len;

		/* New line */
		line++;
		while (file[0] && (file[0] == ' ' || file[0] == 9)) file++;

		/* Get identifier */
		id = file;
		while (file[0] && file[0] > ' ') file++;
		id_len = file - id;

		/* No identifier? */
		if (! id_len) {
			if (file[0]) file++;
			continue;
		}

		/* Skip separator */
		while (file[0] == 9 || file[0] == ' ') file++;

		/* Get value */
		val = file;
		while (file[0] && file[0] != 10 && file[0] != 13) file++;
		val_len = file - val;

		/* Possibly move to new line */
		if (file[0]) {
			if ((file[1] == 10 || file[1] == 13) && file[0] != file[1]) file++;
			file++;
		}

		/* Comment? */
		if (id[0] == '#') continue;

		/* Get token or go on */
		tok = get_token(&id);
		if (!tok) continue;

		tok_len = strlen(tok);

		for (optlist = opt; (option = *optlist); optlist++) {
			int i;

		    	for (i = 0; option[i].cfg_name || option[i].cmd_name; i++) {
				if (option[i].cfg_name &&
				    tok_len == strlen(option[i].cfg_name) &&
				    !casecmp(tok, option[i].cfg_name, tok_len)) {
					unsigned char *value = memacpy(val, val_len);
					unsigned char *err = option[i].rd_cfg(&option[i], value);

					if (err) {
						if (err[0])
							fprintf(stderr, "Error parsing config file %s, line %d: %s\n",
								name, line, err);
						error = 1;
					}

					mem_free(value);
					goto next;
				}
			}
		}

		fprintf(stderr, "Unknown option in config file %s, line %d\n", name, line);
		error = 1;
next:
		if (tok) mem_free(tok);
	}

	if (error) {
		fprintf(stderr, "\007");
		sleep(3);
	}
}

unsigned char *create_config_string(struct option *options)
{
	unsigned char *str = init_str();
	int len = 0;
	int i;

	add_to_str(&str, &len, "# This file is automatically generated by Links -- please do not edit.");

	for (i = 0; options[i].cfg_name || options[i].cmd_name; i++) {
		if (options[i].wr_cfg) {
			options[i].wr_cfg(&options[i], &str, &len);
		}
	}

	add_to_str(&str, &len, NEWLINE);

	return str;
}

#define FILE_BUF	1024

unsigned char cfg_buffer[FILE_BUF];

unsigned char *read_config_file(unsigned char *name)
{
	int h, r;
	int l = 0;
	unsigned char *s;
	if ((h = open(name, O_RDONLY | O_NOCTTY)) == -1) return NULL;
	set_bin(h);
	s = init_str();
	while ((r = read(h, cfg_buffer, FILE_BUF)) > 0) {
		int i;
		for (i = 0; i < r; i++) if (!cfg_buffer[i]) cfg_buffer[i] = ' ';
		add_bytes_to_str(&s, &l, cfg_buffer, r);
	}
	if (r == -1) mem_free(s), s = NULL;
	close(h);
	return s;
}

#undef FILE_BUF


void get_system_name()
{
	FILE *f;
	unsigned char *p;
	memset(system_name, 0, MAX_STR_LEN);
	if (!(f = popen("uname -srm", "r"))) goto fail;
	if (fread(system_name, 1, MAX_STR_LEN - 1, f) <= 0) {
		pclose(f);
		goto fail;
	}
	pclose(f);
	for (p = system_name; *p; p++) if (*p < ' ') {
		*p = 0;
		break;
	}
	if (system_name[0]) return;
	fail:
	strcpy(system_name, SYSTEM_NAME);
}

unsigned char *get_home(int *new)
{
	struct stat st;
	unsigned char *home = stracpy(getenv("HOME"));
	unsigned char *home_links;
	unsigned char *config_dir = stracpy(getenv("CONFIG_DIR"));

	if (new) *new = 1;

	if (!home) {
		int i;

		home = stracpy(path_to_exe);
		if (!home) {
			if (config_dir) mem_free(config_dir);
			return NULL;
		}

		for (i = strlen(home) - 1; i >= 0; i--) {
			if (dir_sep(home[i])) {
				home[i + 1] = 0;
				break;
			}
		}

		if (i < 0) home[0] = 0;
	}

	while (home[0] && dir_sep(home[strlen(home) - 1]))
		home[strlen(home) - 1] = 0;

	if (home[0]) add_to_strn(&home, "/");

	home_links = stracpy(home);

	if (config_dir) {
		add_to_strn(&home_links, config_dir);

		while (home_links[0] && dir_sep(home_links[strlen(home_links) - 1]))
			home_links[strlen(home_links) - 1] = 0;

		if (stat(home_links, &st) != -1 && S_ISDIR(st.st_mode)) {
			add_to_strn(&home_links, "/links");

	    	} else {
			fprintf(stderr, "CONFIG_DIR set to %s. But directory %s doesn't exist.\n\007", config_dir, home_links);
			sleep(3);
			mem_free(home_links);
			home_links = stracpy(home);
			add_to_strn(&home_links, ".links");
		}

		mem_free(config_dir);

	} else {
		add_to_strn(&home_links, ".links");
	}

	if (stat(home_links, &st)) {
		if (!mkdir(home_links, 0700))
			goto home_creat;
		if (config_dir)
			goto failed;
		goto first_failed;
	}

	if (S_ISDIR(st.st_mode))
		goto home_ok;

first_failed:
	mem_free(home_links);

	/* FIXME: home_links == NULL case --Zas */
	home_links = stracpy(home);
	add_to_strn(&home_links, "links");

	if (stat(home_links, &st)) {
		if (mkdir(home_links, 0700) == 0)
			goto home_creat;
		goto failed;
	}

	if (S_ISDIR(st.st_mode))
		goto home_ok;

failed:
	mem_free(home_links);
	mem_free(home);

	return NULL;

home_ok:
	if (new) *new = 0;

home_creat:
#if 0
	/* I've no idea if following is needed for newly created directories.
	 * It's bad thing to do it everytime. */
#ifdef HAVE_CHMOD
	chmod(home_links, 0700);
#endif
#endif
	add_to_strn(&home_links, "/");
	mem_free(home);

	return home_links;
}

void init_home()
{
	get_system_name();
	links_home = get_home(&first_use);
	if (!links_home) {
		fprintf(stderr, "Unable to find or create links config directory. Please check, that you have $HOME variable set correctly and that you have write permission to your home directory.\n\007");
		sleep(3);
		return;
	}
}

void
load_config_file(unsigned char *prefix, unsigned char *name)
{
	unsigned char *c, *config_file;

	config_file = straconcat(prefix, name, NULL);
	if (!config_file) return;

	c = read_config_file(config_file);
	if (c) goto ok;
	mem_free(config_file);

	config_file = straconcat(prefix, ".", name, NULL);
	if (!config_file) return;

	c = read_config_file(config_file);
	if (c) goto ok;

	mem_free(config_file);
	return;

ok:
	parse_config_file(config_file, c, all_options);
	mem_free(c);
	mem_free(config_file);
}

void load_config()
{
	load_config_file("/etc/", "links.cfg");
	load_config_file(links_home, "links.cfg");
	load_config_file(links_home, "html.cfg");
	load_config_file(links_home, "user.cfg");
}

int
write_config_file(unsigned char *prefix, unsigned char *name, struct option *o,
		  struct terminal *term)
{
	int ret = -1;
	struct secure_save_info *ssi;
	unsigned char *config_file;
	unsigned char *cfg_str = create_config_string(o);

	if (!cfg_str) return -1;
	
	config_file = straconcat(prefix, name, NULL);
	if (!config_file) goto free_cfg_str;
	
	ssi = secure_open(config_file, 0177);
	if (!ssi) goto free_config_file;

	secure_fputs(ssi, cfg_str);
	ret = secure_close(ssi);

	if (ret && term) {
		msg_box(term, NULL,
			TEXT(T_CONFIG_ERROR), AL_CENTER | AL_EXTD_TEXT,
			TEXT(T_UNABLE_TO_WRITE_TO_CONFIG_FILE), "\n",
			config_file, ": ", strerror(ret), NULL,
			NULL, 1,
			TEXT(T_CANCEL), NULL, B_ENTER | B_ESC);
	}

free_config_file:
	mem_free(config_file);
	
free_cfg_str:
	mem_free(cfg_str);

	return ret;
}

void write_config(struct terminal *term)
{
	write_config_file(links_home, "links.cfg", links_options, term);
}

void write_html_config(struct terminal *term)
{
	write_config_file(links_home, "html.cfg", html_options, term);
}

void end_config()
{
	if (links_home) mem_free(links_home);
}


/* FIXME: This should be in some .h file! */
extern struct input_history goto_url_history;

/* Load history file */
int load_url_history()
{
	FILE *fp;
	unsigned char *history_file;
	unsigned char url[MAX_INPUT_URL_LEN];

	if (anonymous) return 0;
	/* Must have been called after init_home */
	/* if (!links_home) return 0; */ /* strconcat() checks it --Zas */

	history_file = straconcat(links_home, "links.his", NULL);
	if (!history_file) return 0;

	fp = fopen(history_file, "r");
	if (!fp) {
		mem_free(history_file);
		return 0;
	}

	while (fgets(url, MAX_INPUT_URL_LEN, fp)) {
		url[strlen(url) - 1] = 0;
		add_to_input_history(&goto_url_history, url, 0);
	}

	fclose(fp);
	mem_free(history_file);
	return 0;
}

/* Write history list to file. It returns a value different from 0 in case of
 * failure, 0 on success. */
int
save_url_history()
{
	struct input_history_item* historyitem;
	struct secure_save_info *ssi;
	unsigned char *history_file;
	int i = 0;

	if (anonymous) return 0;

	history_file = straconcat(links_home, "links.his", NULL);
	if (!history_file) return -1;

	ssi = secure_open(history_file, 0177);
	mem_free(history_file);
	if (!ssi) return -1;
	
	foreachback(historyitem, goto_url_history.items) {
		if (i++ > MAX_HISTORY_ITEMS) break;
		secure_fputs(ssi, historyitem->d);
		secure_fputc(ssi, '\n');
		if (ssi->err) break;
	}

	return secure_close(ssi);
}
