/* Info dialogs */
/* $Id: info.c,v 1.77 2003/11/15 16:23:45 pasky Exp $ */

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#ifdef HAVE_UNISTD_H
#include <unistd.h>
#endif

#include "elinks.h"

#include "bfu/msgbox.h"
#include "dialogs/info.h"
#include "dialogs/refresh.h"
#include "config/kbdbind.h"
#include "config/options.h"
#include "cache/cache.h"
#include "document/html/renderer.h"
#include "intl/gettext/libintl.h"
#include "lowlevel/select.h"
#include "modules/version.h"
#include "sched/connection.h"
#include "sched/session.h"
#include "terminal/terminal.h"
#include "util/conv.h"
#ifdef LEAK_DEBUG
#include "util/memdebug.h"
#endif
#include "util/memlist.h"
#include "util/memory.h"
#include "util/string.h"

void
menu_about(struct terminal *term, void *d, struct session *ses)
{
	unsigned char *s = get_dyn_full_version(term, 1);

	if (!s) return;

	msg_box(term, NULL, MSGBOX_FREE_TEXT,
		N_("About"), AL_CENTER,
		s,
		NULL, 1,
		N_("OK"), NULL, B_ENTER | B_ESC);
}

/* TODO: This should be autogenerated. */
void
menu_keys(struct terminal *term, void *d, struct session *ses)
{
	enum keyact actions[] = {
		ACT_MENU,
		ACT_QUIT,
		ACT_DOWN,
		ACT_UP,
		ACT_SCROLL_DOWN,
		ACT_SCROLL_UP,
		ACT_SCROLL_LEFT,
		ACT_SCROLL_RIGHT,
		ACT_BACK,
		ACT_ENTER,
		ACT_GOTO_URL,
		ACT_GOTO_URL_CURRENT,
		ACT_DOCUMENT_INFO,
		ACT_HEADER_INFO,
		ACT_SEARCH,
		ACT_SEARCH_BACK,
		ACT_FIND_NEXT,
		ACT_FIND_NEXT_BACK,
		ACT_DOWNLOAD,
		ACT_TOGGLE_HTML_PLAIN,

		ACT_NONE,
	};
	struct string keys;

	if (!init_string(&keys)) return;

	add_keyactions_to_string(&keys, actions, term);

	msg_box(term, NULL, MSGBOX_FREE_TEXT,
		N_("Keys"), AL_LEFT,
		keys.source,
		NULL, 1,
		N_("OK"), NULL, B_ENTER | B_ESC);
}

void
menu_copying(struct terminal *term, void *d, struct session *ses)
{
	msg_box(term, NULL, MSGBOX_FREE_TEXT,
		N_("Copying"), AL_CENTER,
		msg_text(term, N_("ELinks %s\n"
			"\n"
			"(C) 1999 - 2002 Mikulas Patocka\n"
			"(C) 2001 - 2003 Petr Baudis\n"
			"\n"
			"This program is free software; you can redistribute it "
			"and/or modify it under the terms of the GNU General Public "
			"License as published by the Free Software Foundation; "
			"either version 2 of the License, or (at your option) any "
			"later version."),
			VERSION_STRING),
		NULL, 1,
		N_("OK"), NULL, B_ENTER | B_ESC);
}


void
res_inf(struct terminal *term, void *d, struct session *ses)
{
	struct refresh *r;

	r = mem_alloc(sizeof(struct refresh));
	if (!r)	return;

	msg_box(term, NULL, MSGBOX_FREE_TEXT,
		N_("Resources"), AL_LEFT,
		msg_text(term, N_("Resources: %d handles, %d timers.\n"
			"Connections: %d connections, %d connecting, %d "
			"transferring, %d keepalive.\n"
			"Memory cache: %d bytes, %d files, %d locked, %d "
			"loading.\n"
			"Formatted document cache: %d documents, %d locked."),
			select_info(INFO_FILES), select_info(INFO_TIMERS),
			connect_info(INFO_FILES), connect_info(INFO_CONNECTING),
			connect_info(INFO_TRANSFER), connect_info(INFO_KEEP),
			cache_info(INFO_BYTES), cache_info(INFO_FILES),
			cache_info(INFO_LOCKED), cache_info(INFO_LOADING),
			formatted_info(INFO_FILES), formatted_info(INFO_LOCKED)),
		r, 1,
		N_("OK"), NULL, B_ENTER | B_ESC);

	refresh_init(r, term, ses, d, res_inf);
}

void
cache_inf(struct terminal *term, void *d, struct session *ses)
{
	struct string info;
	struct refresh *r;
	struct cache_entry *ce, *cache;
	unsigned int count = 0;
	int truncated = 0;

	r = mem_alloc(sizeof(struct refresh));
	if (!r)	return;

	if (!init_string(&info)) {
		mem_free(r);
		return;
	}

	cache = (struct cache_entry *) cache_info(INFO_LIST);
	foreach (ce, *cache) {
		if (count++ < term->height - 10) { /* 10 seems a kool value. --Zas */
			add_char_to_string(&info, '\n');
#ifdef DEBUG
			if (ce->incomplete)
				add_char_to_string(&info, '*');
			else /* number of references */
				add_long_to_string(&info, get_cache_entry_refcount(ce));
			add_char_to_string(&info, ' ');
#endif
			/* FIXME: What to do with long urls ? they wrap for now
			 * but if one is very long then no other is displayed. */
			add_uri_to_string(&info, &ce->uri, ~URI_POST);

#ifdef DEBUG
			/* size */
			add_char_to_string(&info, ' ');
			add_knum_to_string(&info, ce->data_size);
#endif
		} else if (!truncated) truncated = count;
	}

	if (!count) {
		add_char_to_string(&info, '\n');
		add_to_string(&info, _("No entry.", term));
	} else if (truncated) {
		unsigned char buf[256];

		add_char_to_string(&info, '\n');

		snprintf(buf, 64, _("%ld more entries.", term),
			count - truncated + 1);
		add_to_string(&info, buf);
	}

	msg_box(term, getml(info.source, NULL), MSGBOX_FREE_TEXT,
		N_("Cache info"), AL_LEFT,
		msg_text(term, N_("Cache content: %s"), info.source),
		r, 1,
		N_("OK"), NULL, B_ENTER | B_ESC);

	refresh_init(r, term, ses, d, cache_inf);
}

#ifdef LEAK_DEBUG

void
memory_inf(struct terminal *term, void *d, struct session *ses)
{
	struct refresh *r;

	r = mem_alloc(sizeof(struct refresh));
	if (!r) return;

	msg_box(term, NULL, MSGBOX_FREE_TEXT,
		N_("Memory info"), AL_LEFT,
		msg_text(term, N_("%ld bytes of memory allocated."),
			 mem_amount),
		r, 1,
		N_("OK"), NULL, B_ENTER | B_ESC);

	refresh_init(r, term, ses, d, memory_inf);
}

#endif
